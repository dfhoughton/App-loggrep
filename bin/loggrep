#!perl

# PODNAME: loggrep
# ABSTRACT: quickly find relevant lines in a log searching by date

use strict;
use warnings;

use Getopt::Long::Descriptive -all;

use constant TPAT => '^\[(.*?) [A-Z]';

my ( $opt, $usage ) = describe_options(
   prog_name() . ' %o [<log file>]',
   [],
   ['Grep lines out of a log.'],
   [],
   [ 'log|l=s',      "log file; may also be provided as an argument" ],
   [ 'include|i=s@', "regex for lines to include; repeatable" ],
   [ 'exclude|v=s@', "regex for lines to exclude; repeatable" ],
   [ 'quote|q',   'do not treat expressions to include or exclude as regexes' ],
   [ 'start|s=s', "start timestamp; first time in log by default" ],
   [ 'end|e=s',   "end timestamp; last time in log by default" ],
   [
      'date|d=s',
      "a pattern to be used to find the timestamp in a log line; default: "
        . TPAT,
      { default => TPAT }
   ],
   [],
   [ 'warn|w', "warn of lines without dates" ],
   [ 'die',    "throw an error upon finding a line without a date" ],
   [],
   [ 'blank|b', 'print a blank separator line between non-adjacent log lines' ],
   [ 'separator|sep=s', 'a separator to print between non-adjacent blocks' ],
   [
      'context|C=i',
      'a number of lines before and after the match line to show'
   ],
   [ 'before|B=i', 'a number of lines before the match line to show' ],
   [ 'after|A=i',  'a number of lines after the match line to show' ],
   [],
   [
      'time|t=s',
      'perl code to convert a log line into a Unix timestamp; '
        . 'this is an alternative to --date'
   ],
   [
      'exec|E=s',
      'perl code to call before printing a line; '
        . '@_ will contain the line, the line number, and whether it was a match;'
        . ' the value returned by this code is what will be printed'
   ],
   [
      'module|M=s@',
      'Perl module to load for use by --time or --exec code; repeatable'
   ],
   [],
   [ 'help|h|?', "print usage message and exit" ],
   [ 'version',  'print ' . prog_name() . "'s version number" ],
);

usage() if $opt->help;
require App::loggrep;
print( prog_name() . " $App::loggrep::VERSION\n" ), exit if $opt->version;

my @errors;
push @errors, 'you cannot specify both --warn and --die'
  if $opt->warn && $opt->die;

my $grepper = App::loggrep->new( $opt->log // shift, $opt );
push @errors, $grepper->init;

error() if @errors;

$grepper->grep;

# print errors and minimal usage information
sub error {
   return unless @errors;
   print STDERR "ERRORS\n\n";
   print STDERR "\t$_\n" for @errors;
   print STDERR "\n";

   print STDERR $usage->text;
   exit;
}

# print maximal usage information
sub usage {
   print $usage->text;
   print <<"END";

@{[prog_name()]} facilitates search for lines in a log file within a specified date range.
If you aren't interested in filtering by date range, use grep instead.

If multiple expression to include are provided, a line which matches any will be printed.
Likewise, if a line matches any of the exclusion expressions, it will be excluded.

@{[prog_name()]} uses Date::Parse to convert a timestamp into a Unix timestap (a number of
seconds since time zero). Date::Parse is pretty clever, but if it doesn't understand your
timestamps you'll have to use the --time option. If you want to use a particular module,
like Date::Parse or DateTime, in your --time code, you'll have to use or require it inside
your code or load it in with the --module option like so

  -M Date::Parse --time '(\$m=shift)=~s/(.*?) foo/\$1/;\$m eq "bar" ? 1 : str2time \$m'

END
   exit;
}
